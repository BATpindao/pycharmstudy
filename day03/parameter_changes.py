# 参数的传参机制 和 可变参数，不可变参数 使用的一些细节
"""
Python 参数传递机制详解
Python 的参数传递机制是很多初学者容易混淆的地方。它不是'按值传递'，也不是严格的'按引用传递'，
官方描述是 “按对象引用传递”（Pass by Object Reference），或者更通俗地说是 “按赋值传递”（Pass by Assignment）。

核心原理
1.Python 中一切都是对象，变量名只是对对象的'引用'（像指针）。
2.函数调用时，形参会被绑定到实参指向的'同一个对象'（引用复制）。
3.函数内部的行为取决于对象的"可变性"：
    .不可变对象（immutable）：int、float、str、tuple、frozenset 等。
        1.如果在函数内“修改”它（比如 x = x + 1），其实是创建了一个新对象，形参指向新对象，原实参不变。

    .可变对象（mutable）：list、dict、set、bytearray、自定义类实例（默认可变）等。
        1.如果在函数内就地修改（如 list.append()），会直接改变原对象，外部实参也会看到变化。
        2.如果重新赋值（如 lst = [新列表]），形参指向新对象，原实参不变。

形象比喻：
    1.传递的是“房子的地址标签”的副本。
    2.如果你用地址去装修房子（就地修改可变对象）→ 房子变了，外部也看到。
    3.如果你换了个新房子地址（重新赋值）→ 你自己住新房子，外部还是老房子。
"""

# 1.不可变对象的坑
"""
下面的 x 看起来是修改，其实是重新绑定   从内存地址上看修改后的值就是重新赋值了
"""
def func(x):
    print('修改前的地址：',id(x)) # 修改前的地址： 4329628360
    x+=1
    print('修改后的地址：',id(x)) # 修改后的地址： 4329628392
    print(x)

a = 5
func(a)
print(a,id(a)) #外部还是五 4329628360


print()
# 2.可变对象的坑
"""
lst = [5,6] 这其实是重新赋值 内存地址都变了 和外部的内存地址不一样
"""
def modify(lst):
    lst.append(4) # 就地修改 -> 外部变
    lst.extend([5,7,['anna']])
    print('赋值前，内存地址：',id(lst))
    lst = [5,6]   # 重新赋值 -> 外部不变
    print('赋值后，内存地址：', id(lst))

my_list = [1,2,3]
modify(my_list)
print(f'内存地址：{id(my_list)}',my_list)   # [1,2,3,4] (append 生效，重新赋值没有生效)


print()
# 3.默认参数的超级大坑（最经典！）：
"""
默认值在‘函数定义时’计算一次，且如果默认是可变对象，会在多次调用间 ‘共享’。
"""
# 错误示范
def bad(lst= []):
    lst.append(1)
    return lst

print(bad()) # [1]
print(bad()) # [1,1] 共享同一个列表

# 正确的示范。 用None站位
def add_bad(lst = None):
    if lst is None:
        lst = []
    lst.append(1)
    return lst

print(add_bad()) # [1]
print(add_bad()) # [1]  每次刷新列表


print()
"""
    4.+= 操作符的坑：
        .对于不可变对象：创建新对象（像重新赋值）。
        .对于可变对象：可能就地修改（list += [1] 会修改原列表）。
"""



print()
"""
   5.其他坑：
        .元组含可变对象时，元组本身不可变，但内部可变对象可改。
"""
t = ([1,2],2)
t[0].append(4) # 合法  ([1, 2, 4], 2)
# t[0] = [4,5]   报错 因 t[0]的内存地址变了 ，而上面那一个的 t[0]元素的内存地址是没有变的
print(t)